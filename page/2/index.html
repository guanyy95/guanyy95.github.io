<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>蹲在天边拉屎</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="蹲在天边拉屎">
<meta property="og:url" content="https://guanyy95.github.io/page/2/index.html">
<meta property="og:site_name" content="蹲在天边拉屎">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="GYY">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="蹲在天边拉屎" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">蹲在天边拉屎</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://guanyy95.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2021-11-05工作小结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/07/2021-11-05%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-11-07T03:02:21.000Z" itemprop="datePublished">2021-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%81%8C%E5%9C%BA/">职场</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/07/2021-11-05%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%BB%93/">2021.11.05工作小结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>入职新的公司已经有快一个月的时间了，前两周的工作主要是进入对公司日常考勤、沟通等制度方面的熟悉。熟悉团队的版本控制系统，项目开发进度流程工具以及项目中的框架和常用的封装组件使用。因为整个项目在逻辑层全部使用Lua语言进行开发，所以第一周和第二周的时间熟悉语言然后是框架项目。</p>
<p>个人第一点很直观的感受，项目中leader布置的任务都很具有针对性。任务重包含了90%的工作使用场景，可以在没有项目实际压力的情况下去熟悉整个开发流程并且帮助你去发现一些你可能注意不到的一些微小地方。第二点，越是体量大的项目，对工具的二次开发和封装使用就越多。有时候你甚至不需要懂得Unity的使用依然能够完成正常的开发任务。同样的，你也要去单独花时间去熟悉所有封装好的工具、脚本等。对于不太熟悉Unity API的话，就需要花时间去辨别工具是原生组件还是封装过的组件，对我个人而言有时候通过看文档或者是询问同事相关工具的使用之后还是要去自己过一遍源码了解一些原理机制，这样才能够在BUG出现的时候第一时间找到问题点，不然就只能对着自己写的代码一脸蒙蔽。第三点，身边同事的帮助确实很大，问题一抛出的时候基本都可以得到热情的回复。</p>
<p><strong>文档反复看！文档反复看！文档反复看！</strong></p>
<p>很多问题的解决方法都在文档中，包括怎么用，怎么改，原理啥的。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>从第一周需求的完成中还是发现了对项目需求的不熟悉，不单单是当下需求中的内容。整个游戏中的流程和连带的一些游戏内容。对于同任务的其他人来说没有什么gap，所以有时候会默认忽略掉。但是这些细节都会阻碍我需求的准确完成。每个新需求的提出都会通过宣讲会进行一个讲解，但是由于还没有熟悉内容就进行了宣讲所以会错过很多提问的机会。这确实会对后续开发有些阻碍。所以还是要加强对项目的熟悉包括玩法流程、测试方法、实现细节等。</li>
<li>Unity + Lua的开发环境会不像纯C#开发那样依靠IDE帮助自己理清所有的代码流程。Lua会在中间出现断层，依靠一些经验和调试工具去理清这个脉络。包括Lua语言上的一些机制，在阅读代码中有时会不如C#代码看的简洁明了。Lua这种脚本语言在没有类型判断的时候确实是在写方面有优势，但对于读熟系业务流程不如有类型提示的语言看起来方便。自己目前对Lua数据结构的判断还不够熟系。</li>
<li>在之前实习的过程中，对于需求总是很快的开始动手写代码开干了，缺少了对需求中要完成的内容的整体规划。有时候写着写着就感觉不对劲了，改之前写的接口，重新确认数据结构。或者是写着写着觉得整体规划不合理了，继续写就是能跑的烂代码了，但是修改就需要花额外时间了。自己还需要在开始写代码进行一个清晰的规划，提前预判或者测试解决可能会出现的难点。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guanyy95.github.io/2021/11/07/2021-11-05%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%BB%93/" data-id="cm7o74kk90008esw45yjb733r" data-title="2021.11.05工作小结" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Lua源码编译" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/25/Lua%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/" class="article-date">
  <time class="dt-published" datetime="2021-10-25T15:58:09.000Z" itemprop="datePublished">2021-10-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Lua/">Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/25/Lua%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">Lua源码编译</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Lua源码编译"><a href="#Lua源码编译" class="headerlink" title="Lua源码编译"></a>Lua源码编译</h1><h2 id="1-下载lua源码解压缩"><a href="#1-下载lua源码解压缩" class="headerlink" title="1.下载lua源码解压缩"></a>1.下载lua源码解压缩</h2><h2 id="2-VS创建-lib静态库项目"><a href="#2-VS创建-lib静态库项目" class="headerlink" title="2. VS创建.lib静态库项目"></a>2. VS创建.lib静态库项目</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0234daa6d7314c3ca3e0fab322ab8579~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa633d870034c3fa1308f5760f80fe5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eed495cc72fc43a789f3867db01e1c7f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ace5ccab3ba54fb3b086bd82758b425a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88a1d16af4054e8abc7342469bf3ad3f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a029afd272a547deab1be359d4db458a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>Build Solution在工程Release文件夹中找到.lib文件，将文件拷贝到lua源码根目录下。</p>
<h2 id="3-创建C-控制台Console-Application"><a href="#3-创建C-控制台Console-Application" class="headerlink" title="3.创建C++控制台Console Application"></a>3.创建C++控制台Console Application</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bebeec3ede794d9485aeb364e0ba802d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea06c7b7477b4cb290764fca256f4d2c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>选择链接器–输入–附加依赖项–输入我们所编译的lua5.4.1.lib库文件名称(刚才生成后拷贝到Lua源码目录下的静态链接库)。然后点击应用，确定就好了。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37ba6abda01948c195da4341ee772798~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>在C++工程中创建Main.lua文件脚本</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8206f47f2c5d44ac969d0b3bca2aba5c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>Runlua.cpp作为虚拟机启动脚本</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12930d7e918b497f862100d26d4c95b9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="跑起项目输出lua脚本内容"><a href="#跑起项目输出lua脚本内容" class="headerlink" title="跑起项目输出lua脚本内容"></a>跑起项目输出lua脚本内容</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://guanyy95.github.io/2021/10/25/Lua%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/" data-id="cm7o74kkb000eesw47kwn73a3" data-title="Lua源码编译" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-lua面向对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/23/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="dt-published" datetime="2021-09-23T04:38:34.000Z" itemprop="datePublished">2021-09-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Lua/">Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/23/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">lua面向对象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在Lua这门语言中，和Javascript面向对象的原理十分相像，使用原型的方式进行对元数据的拷贝复制和拓展。借助原表(metatable)来限定一个原型的基本行为。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Object = &#123;&#125;</span><br><span class="line"><span class="comment">--实例化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:new</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;&#125;</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, <span class="built_in">self</span>)</span><br><span class="line">    <span class="keyword">return</span> obj    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:subClass</span><span class="params">(className)</span></span></span><br><span class="line">    <span class="built_in">_G</span>[className] = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> obj = <span class="built_in">_G</span>(className)</span><br><span class="line"></span><br><span class="line">    obj.base = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, <span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://guanyy95.github.io/2021/09/23/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" data-id="cm7o74kke000qesw41xky4lyl" data-title="lua面向对象" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-lua深拷贝" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/22/lua%E6%B7%B1%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time class="dt-published" datetime="2021-09-22T00:48:10.000Z" itemprop="datePublished">2021-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Lua/">Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/22/lua%E6%B7%B1%E6%8B%B7%E8%B4%9D/">lua深拷贝</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DeepCopy1</span><span class="params">(obj)</span></span></span><br><span class="line">    <span class="keyword">local</span> InTable = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Func</span><span class="params">(obj)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(obj) ~= <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> NewTable = &#123;&#125;</span><br><span class="line">        InTable[obj] = NewTable</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(obj) <span class="keyword">do</span></span><br><span class="line">        NewTable[Func(k)] = Func(v) </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setmetatable</span>(NewTable, <span class="built_in">getmetatable</span>(obj))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> Func(obj)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DeepCopy2</span><span class="params">(obj)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">copy</span><span class="params">(obj)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(obj) ~= <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> newTable = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(obj) <span class="keyword">do</span></span><br><span class="line">            newTable[copy(k)] = copy(v)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setmetatable</span>(newTable, <span class="built_in">getmetatable</span>(obj))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copy(obj)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://guanyy95.github.io/2021/09/22/lua%E6%B7%B1%E6%8B%B7%E8%B4%9D/" data-id="cm7o74kke000uesw47kl56v61" data-title="lua深拷贝" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-225队列实现栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/19/225%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2021-09-19T02:25:29.000Z" itemprop="datePublished">2021-09-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/19/225%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/">225队列实现栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-stack-using-queues/">https://leetcode-cn.com/problems/implement-stack-using-queues/</a></p>
<h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><blockquote>
<p>LeetCode225用队列的形式实现栈的操作，队列是FIFO先进先出的模式，栈是FILO先进后出的模式。</p>
</blockquote>
<h2 id="简单思路"><a href="#简单思路" class="headerlink" title="简单思路"></a>简单思路</h2><p><strong>PUSH</strong>：使用一个标记位标记栈顶元素，直接enqueue到队列中即可，每次enqueue的元素就为栈顶元素。</p>
<p><strong>POP</strong>：POP操作需要移除栈顶元素，dequeue只能出队栈底元素。循环从队列头将元素去除重新入队到队尾，同时保留倒数第二个元素标记栈顶元素，出队队首元素。</p>
<p><strong>PEEK</strong>：直接返回标记元素</p>
<h2 id="贴代码"><a href="#贴代码" class="headerlink" title="贴代码"></a>贴代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    <span class="type">int</span> top_ele;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        top_ele = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        q.offer(x);</span><br><span class="line">        top_ele = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            q.offer(q.poll());</span><br><span class="line">            size --;</span><br><span class="line">        &#125;</span><br><span class="line">        top_ele = q.poll();</span><br><span class="line">        q.offer(top_ele);</span><br><span class="line">        <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top_ele;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://guanyy95.github.io/2021/09/19/225%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/" data-id="cm7o74kk70004esw4aoxh78de" data-title="225队列实现栈" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-搜索算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/15/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-09-15T02:16:45.000Z" itemprop="datePublished">2021-09-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/15/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/">搜索算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><h2 id="普通搜索"><a href="#普通搜索" class="headerlink" title="普通搜索"></a>普通搜索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length - 1</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right]</span><br><span class="line">所以决定了 while (left &lt;= right)</span><br><span class="line">同时也决定了 left = mid+1 和 right = mid-1</span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找左边界"><a href="#寻找左边界" class="headerlink" title="寻找左边界"></a>寻找左边界</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 while (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + 1 和 right = mid</span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;\</span><br><span class="line">    &#125;\</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找右边界"><a href="#寻找右边界" class="headerlink" title="寻找右边界"></a>寻找右边界</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 while (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + 1 和 right = mid</span><br><span class="line">\</span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line">又因为收紧左侧边界时必须 left = mid + 1</span><br><span class="line">所以最后无论返回 left 还是 right，必须减一</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;\</span><br><span class="line">    &#125;\</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://guanyy95.github.io/2021/09/15/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/" data-id="cm7o74kkh0019esw49drz2e43" data-title="搜索算法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Unity渲染优先级总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/08/Unity%E6%B8%B2%E6%9F%93%E4%BC%98%E5%85%88%E7%BA%A7%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-09-08T03:17:24.000Z" itemprop="datePublished">2021-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity/">Unity</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/08/Unity%E6%B8%B2%E6%9F%93%E4%BC%98%E5%85%88%E7%BA%A7%E6%80%BB%E7%BB%93/">Unity渲染优先级总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Unity中的渲染类图关系"><a href="#Unity中的渲染类图关系" class="headerlink" title="Unity中的渲染类图关系"></a>Unity中的渲染类图关系</h1><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8efd1550c7d4f1b8a852bf088996237~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h1 id="UGUI系统中的渲染优先级"><a href="#UGUI系统中的渲染优先级" class="headerlink" title="UGUI系统中的渲染优先级"></a>UGUI系统中的渲染优先级</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e3f2635f85840aba7d16cd345fc3b54~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="显示优先级总共分为4类"><a href="#显示优先级总共分为4类" class="headerlink" title="显示优先级总共分为4类"></a>显示优先级总共分为4类</h2><h3 id="1-当Canvas为ScreenSpace-Overlay模式"><a href="#1-当Canvas为ScreenSpace-Overlay模式" class="headerlink" title="1. 当Canvas为ScreenSpace-Overlay模式"></a>1. 当Canvas为ScreenSpace-Overlay模式</h3><p>在这种模式下，UGUI内容永远优先显示在所有物体前面，Canvas本身的渲染根据在Hireachy中的先手顺序有关，不同Canvas根据sortinglayer值决定。所有的3D物体均在Canvas之下渲染。</p>
<h3 id="2-WorldSpace-VS-ScreenSpace模式"><a href="#2-WorldSpace-VS-ScreenSpace模式" class="headerlink" title="2. WorldSpace VS ScreenSpace模式"></a>2. WorldSpace VS ScreenSpace模式</h3><p>canvas渲染根据实际gameobject的z轴和sorting order或者是order in layer决定。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6d0fe7c0dcb49eab89e84a99f866d92~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6265c40808bb4702bc6f78f012ea4b45~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="3-SpriteRender与canvas的非Overlay模式"><a href="#3-SpriteRender与canvas的非Overlay模式" class="headerlink" title="3. SpriteRender与canvas的非Overlay模式"></a>3. SpriteRender与canvas的非Overlay模式</h3><p>当canvas处于WorldSpace和ScreenSpace-Camera模式下时，基本就相当于SpriteRenderer，渲染方式是一致的。</p>
<p>如果把SpriteRenderer和WorldSpace、ScreenSpace-Overlay并列起来，可以看到这三者之中任何两者相交的渲染方式的影响参数和参数优先级是一致的(也就是上面思维导图中绿色背景内容)。<br>这里可以统一把这三种叫做 “三维空间中的平面渲染对象”。</p>
<h3 id="4-MeshRender与三位空间平面渲染对象比较"><a href="#4-MeshRender与三位空间平面渲染对象比较" class="headerlink" title="4. MeshRender与三位空间平面渲染对象比较"></a>4. MeshRender与三位空间平面渲染对象比较</h3><p>规律根据导图橙色部分决定，MeshRender不受sorting order控制，只受position.z控制，z值越小越显示在更上层。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guanyy95.github.io/2021/09/08/Unity%E6%B8%B2%E6%9F%93%E4%BC%98%E5%85%88%E7%BA%A7%E6%80%BB%E7%BB%93/" data-id="cm7o74kke000tesw44308fp14" data-title="Unity渲染优先级总结" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-排序算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-09-02T10:17:35.000Z" itemprop="datePublished">2021-09-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="排序算法汇总"><a href="#排序算法汇总" class="headerlink" title="排序算法汇总"></a>排序算法汇总</h1><p>11<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28246771cf93438291f8f0e30a1db1aa~tplv-k3u1fbpfcp-watermark.image" alt="排序算分分析.png"></p>
<h2 id="冒泡排序，选泽排序，插入排序-时间复杂度O-N-2-空间复杂度-O-1"><a href="#冒泡排序，选泽排序，插入排序-时间复杂度O-N-2-空间复杂度-O-1" class="headerlink" title="冒泡排序，选泽排序，插入排序(时间复杂度O(N^2) , 空间复杂度 O(1))"></a>冒泡排序，选泽排序，插入排序(时间复杂度O(N^2) , 空间复杂度 O(1))</h2><p>三种算法都是Inplace不占据额外空间</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>从未排序部分选择最小值按顺序放入数组前端有序部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>选择排序使用贪心思想，当前最优换取全局最优。</p>
<p><strong>优点</strong> : 交换次数最少，交换的成本高可以选择</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>将目标元素插入有序数组中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; nums[j-<span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：插入排序可以提前结束循环当前部数组已经有序的时候，可以实现O(N)的时间复杂度。适用于数组规模小的数组。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>两两比较交换位置，每一循环确定最后一位最大值</p>
<p>暴力解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[j-<span class="number">1</span>])</span><br><span class="line">                swap(nums, j, j-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化解法：<br>暴力解法中如果后面为已经有序数组，没有必要继续循环比较，可以设置标志位提前跳出循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//发生了交换就为true, 没发生就为false，第一次判断时必须标志位true。</span></span><br><span class="line">    <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">        flag=<span class="literal">false</span>;<span class="comment">//每次开始排序前，都设置flag为未排序过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j-<span class="number">1</span>] &gt; nums[j])&#123;<span class="comment">//前面的数字大于后面的数字就交换</span></span><br><span class="line">                swap(nums, j, j-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//表示交换过数据;</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k--;<span class="comment">//减小一次排序的尾边界</span></span><br><span class="line">    &#125;<span class="comment">//end while</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更加优化：<br>对于已经排序过的部分不再进行遍历，减少问题规模</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> k;</span><br><span class="line">    <span class="keyword">while</span> (flag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        k = flag;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j-<span class="number">1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                swap(nums, j, j-<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                flag = j; <span class="comment">// 记录最后一次交换的边界位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：实现简单，针对数据规模较小的情况下比较合适。</p>
<h2 id="归并排序，快速排序-Average-O-NlogN"><a href="#归并排序，快速排序-Average-O-NlogN" class="headerlink" title="归并排序，快速排序 Average O(NlogN)"></a>归并排序，快速排序 Average O(NlogN)</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序需要额外的空间O(n)</p>
<p>借助额外空间，合并两个有序数组，得到更长的有序数组，使用分治的思想，可以实现并行化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, len-<span class="number">1</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对数组 nums 的子区间 [left, right] 进行归并排序</span></span><br><span class="line"><span class="comment"> * 优化，当区间范围小于7时可以使用插入排序代替归并</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp  用于合并两个有序数组的辅助数组，全局使用一份，避免多次创建和销毁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// int mid = (left + right) &gt;&gt; 1;</span></span><br><span class="line">    </span><br><span class="line">    mergeSort(nums, left, mid, temp);</span><br><span class="line">    mergeSort(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">    <span class="comment">// 如果2个区间已经有序，不需要递归继续分裂</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mergeTwoSortedArray(nums, left, mid, right, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序数组：先把值复制到临时数组，再合并回去</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid   [left, mid] 有序，[mid + 1, right] 有序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp  全局使用的临时数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mergeTwoSortedArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span> temp)</span> &#123;</span><br><span class="line">    System.arraycopy(nums, left, temp, left, right-left+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">//左序列index</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>; <span class="comment">// 有序列指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// temp数组index</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid +<span class="number">1</span> &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">            temp[t] = nums[i];</span><br><span class="line">            t++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[t] = nums[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[t] = nums[i];</span><br><span class="line">        t++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[t] = nums[j];</span><br><span class="line">        t++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将temp数组考回nums</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        nums[left] = temp[t];</span><br><span class="line">        left++;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：借助额外空间，实现了稳定排序。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>平均时间复杂度O(NlogN), 最差情况复杂度为O(N ^ 2)</p>
<p>核心思想类似整理扑克牌，每一次循环确定pivot的具体位置。随机选择pivot可以防止递归子数组大小平均，防止出现最差情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span> <span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low, j = high, index = array[i]; <span class="comment">// 取最左边的数作为基准数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt;= index) &#123; <span class="comment">// 向左寻找第一个小于index的数</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            array[i++] = array[j]; <span class="comment">// 将array[j]填入array[i]，并将i向右移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt; index) &#123;<span class="comment">// 向右寻找第一个大于index的数</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            array[j--] = array[i]; <span class="comment">// 将array[i]填入array[j]，并将j向左移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array[i] = index; <span class="comment">// 将基准数填入最后的坑</span></span><br><span class="line">    quickSort(array, low, i - <span class="number">1</span>); <span class="comment">// 递归调用，分治</span></span><br><span class="line">    quickSort(array, i + <span class="number">1</span>, high); <span class="comment">// 递归调用，分治</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：平均效率高，对比归并排序不需要额外内存空间，在原地交换。</p>
<h3 id="堆排序-Average-O-NlogN"><a href="#堆排序-Average-O-NlogN" class="headerlink" title="堆排序 Average O(NlogN)"></a>堆排序 Average O(NlogN)</h3><p>使用堆进行存储元素，不断对堆进行堆化，然后逐一选出堆顶元素。堆本身就是一个<strong>完全二叉树的顺序存储结构</strong>，建堆得过程为O(N)，调整堆的时间复杂度O(logN)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] buildHeap(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> (nums.length - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lastIndex; i ++) &#123;</span><br><span class="line">        heapify(nums, i, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>; i &lt; length - <span class="number">1</span>; i = <span class="number">2</span>*i+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 可以选择直接同事比较三个数的大小</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; length &amp;&amp; nums[i] &lt; nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= nums[i]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 根节点 &gt;=左右子女中关键字较大者，调整结束</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[index] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    nums = buildHeap(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">it</span> <span class="variable">i</span> <span class="operator">=</span> nums.length-<span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        heapfiy(nums, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：堆排序利用大值或者小值永远优先于子，可用于解决TOPk问题，可以分批读取原数组，防止内存爆满。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guanyy95.github.io/2021/09/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-id="cm7o74kkg0017esw4cr3g2rk3" data-title="排序算法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-垃圾回收算法笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/02/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-09-02T03:09:00.000Z" itemprop="datePublished">2021-09-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/02/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">垃圾回收算法笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>这篇文章主要用于最近在读的垃圾回收算法与实现这本书中的各种方法的总结，边读边进行记录。方便之后会看的时候可以直接进行查阅。</p>
</blockquote>
<h2 id="基本概念名词"><a href="#基本概念名词" class="headerlink" title="基本概念名词"></a>基本概念名词</h2><p><strong>头</strong> 保存对象本身信息,包含对象的大小和对象的种类，每种算法的实现中头包含的内容也不相同</p>
<p><strong>域</strong> 对象使用者在对象中可访问的部分为域。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ddf3222eb4d4c919e65217be55f89f6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>mutator</strong> mutator就是程序本身</p>
<p><strong>活动&#x2F;非活动对象</strong> 能通过mutator引用访问到的对象为活动对象，反之为非活动对象。</p>
<p><strong>根root</strong> 直接或间接从全局变量空间引用的对象为活动对象。能作为根的对象，</p>
<ol>
<li>全局static变量</li>
<li>栈中变量(代码中方法的局部变量)</li>
<li>寄存器</li>
<li>常量</li>
<li>本地方法栈中引用的对象</li>
<li>已经启动并且未停止的线程</li>
</ol>
<p><strong>评价标准</strong> 吞吐量，最大暂停时间，堆使用效率，访问局部性</p>
<h2 id="GC-标记-清除算法"><a href="#GC-标记-清除算法" class="headerlink" title="GC-标记-清除算法"></a>GC-标记-清除算法</h2><p>标记阶段把所有活动对象做上标记，清除阶段把没有标记的对象回收。</p>
<p><strong>标记阶段</strong>：遍历对象并标记。使用深度优先搜索比广度优先搜索使用更少的内存。</p>
<p><strong>清除阶段</strong>：遍历堆内存，根据标记位进行对象内存的清除，把垃圾对象所占用的内存地址链接到空闲连链表</p>
<p><strong>分配过程</strong>：进行新的对象创建的时候，搜索空闲链表找到空闲的内存地址空间。</p>
<h3 id="优先"><a href="#优先" class="headerlink" title="优先"></a>优先</h3><ol>
<li>实现简单</li>
<li>与保守式算法兼容，GC标记清除算法不会移动对象，</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>碎片化</li>
<li>分配速度，所有操作都需要遍历空闲链表和堆空间。</li>
<li>与写时复制技术不兼容，写时复制属于延时操作，GC回收时不应该直接操作内存空间。</li>
</ol>
<h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p><strong>BiBOP</strong><br>利用类似字典哈希的方法对内存中的分块进行管理，不同大小分块对应不同的链表，在分配的时候可以有效提升分配效率，避免了遍历整个空闲链表</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7140282dadae435f817e5d3a014a8474~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>位图标记</strong><br>使用bitmap将所有的堆内存地址空间进行映射，有效解决了缺点第三条的写时复制相冲突，可以作伪删除操作</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc523f03a31d4a3f983ef72117a1a418~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数的方法是在所有的Object属性中增加一个计数器头。当对象被引用之后，计数器+1， 反之计数器-1。当计数器的值为0的时候，GC程序判断此对象为垃圾对象，将其加入到空闲链表当中发现时立即进行回收。对象自身会对自己进行判断。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>可立即进行垃圾回收，GC程序的运行和内存管理同时进行，可以提高分配时的成功率。</li>
<li>最大暂停时间短，GC程序的回收工作只发生在发现垃圾的时候。减少GC的运行时间。</li>
<li>没有必要沿指针查找</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>计数器增减操作频繁</li>
<li>计数器占位空间</li>
<li>无法处理循环引用</li>
</ol>
<h2 id="部分标记-清除算法"><a href="#部分标记-清除算法" class="headerlink" title="部分标记-清除算法"></a>部分标记-清除算法</h2><p>部分标记清除算法目的是为了解决引用计数方法中存在的无法回收循环引用对象的问题。GC进行标记清除是遍历所有对象，产生无用的搜索。</p>
<p><strong>“部分标记 - 清除算法”（Partial Mark &amp; Sweep）查找非活动对象。</strong><br>所有对象将标记不同颜色</p>
<ol>
<li>黑：绝对不是垃圾的对象（对象产生式的初始颜色）</li>
<li>白：绝对是垃圾的对象</li>
<li>灰：所有过的对象</li>
</ol>
<h2 id="持续更新中—"><a href="#持续更新中—" class="headerlink" title="持续更新中—-"></a>持续更新中—-</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://guanyy95.github.io/2021/09/02/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" data-id="cm7o74kkg0013esw4hu2d3r4w" data-title="垃圾回收算法笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-15三数之和" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/02/15%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" class="article-date">
  <time class="dt-published" datetime="2021-09-02T03:06:19.000Z" itemprop="datePublished">2021-09-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/02/15%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">15三数之和</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组，<strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<p>示例1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出： [[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>
<p>示例2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： nums = []</span><br><span class="line">输出： []</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i +  <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right --;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left ++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right --;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left ++;</span><br><span class="line"></span><br><span class="line">                    right --;</span><br><span class="line">                    left ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://guanyy95.github.io/2021/09/02/15%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" data-id="cm7o74kk50001esw4e3t661mp" data-title="15三数之和" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Lua/">Lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Testing/">Testing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/">Unity</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C#</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%81%8C%E5%9C%BA/">职场</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/28/Unity%E4%BC%98%E5%8C%96%E7%AF%87-Texture%E7%BA%B9%E7%90%86/">Unity优化篇-Texture纹理</a>
          </li>
        
          <li>
            <a href="/2024/10/23/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2023/07/22/%E3%80%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E3%80%91UGUI%E5%90%88%E6%89%B9%E9%97%AE%E9%A2%98/">【游戏开发】UGUI合批问题</a>
          </li>
        
          <li>
            <a href="/2023/01/25/%E6%A0%B9%E6%8D%AE%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90pdf%E5%90%88%E5%90%8C%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">根据模板生成pdf合同脚本使用说明</a>
          </li>
        
          <li>
            <a href="/2022/12/10/Lua%E5%A5%87%E6%B7%AB%E5%B0%8F%E6%8A%80%E5%B7%A7/">Lua奇淫小技巧</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 GYY<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>